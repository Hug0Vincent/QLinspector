# WTF am I doing ?
# This is a python script that parse CodeQL extension files
# and generate C# stubs and test cases for each entry.
# I didn't manage to use the CodeQL way: https://github.com/github/codeql/discussions/20565
# This is generated by AI.

import re
import os
import yaml
import argparse
from collections import defaultdict

# ---------------------------
# Configuration
# ---------------------------

# Blocklist of types not to generate namespace/class stubs for
TYPE_BLOCKLIST = {
    "System.String",
    "System.Int32",
    "System.Boolean",
    "System.Object",
    "System.Byte",
    "System.IO.Stream",
    "System.Xml.XmlReader",
    "System.IO.TextReader",
    "System.IO.MemoryStream", 
    "System.IO.BinaryReader"
}

# Always present methods (will merge with any existing namespace/class)
ALWAYS_METHODS = [
    #["System.Xml", "XmlReader", True, "Create", "(System.IO.TextReader)", "", "", ""]
]

# ---------------------------
# Helper Functions
# ---------------------------

def extract_base_types(type_str):
    """Extract base types from generic or array types."""
    type_str = type_str.strip()
    type_str = re.sub(r"\[\]$", "", type_str)  # Remove array brackets
    generics = re.findall(r"<([^<>]+)>", type_str)
    base_types = [re.sub(r"<.*>", "", type_str)]  # outer type
    for g in generics:
        base_types.extend([t.strip() for t in g.split(",")])
    return base_types

def get_namespace_class(type_name):
    """Split a type into namespace and class name."""
    #type_name = type_name.replace("+", ".")
    if "." in type_name:
        parts = type_name.split(".")
        return ".".join(parts[:-1]), parts[-1]
    return "Global", type_name

def add_class_method(ns_dict, full_class_name, method):
    """
    Add a method to the tree-based class structure, handling nested classes with '+'.
    Deduplicates methods automatically.
    """
    parts = full_class_name.split('+')
    current = ns_dict
    for part in parts[:-1]:
        current = current.setdefault(part, {"methods": [], "nested": {}})["nested"]
    last = parts[-1]
    node = current.setdefault(last, {"methods": [], "nested": {}})
    # Deduplicate by method signature
    sig = f"{method[1]}{method[2]}"
    if not any(f"{m[1]}{m[2]}" == sig for m in node["methods"]):
        node["methods"].append(method)

def add_default_constructors(tree):
    for class_name, class_node in tree.items():
        # Add constructor if not already there
        constructor_signature = (True, class_name, "()")
        if not any(m for m in class_node["methods"] if m[1] == class_name and m[2] == "()"):
            class_node["methods"].append(constructor_signature)

        # Recurse into nested classes
        if "nested" in class_node:
            add_default_constructors(class_node["nested"])

def write_class(f, node, class_name, indent=1):
    """
    Recursively write a class and its nested classes from a node.
    """
    indent_str = "    " * indent
    base_class_name = class_name.split('+')[-1]  # only last part

    f.write(f"{indent_str}public class {base_class_name} {{\n")

    # Write methods
    for is_pub, method_name, signature in node.get("methods", []):
        # Constructor if method_name matches full class path or ends with '+BaseName'
        if method_name == class_name or method_name.endswith(f"+{base_class_name}"):
            f.write(f"{indent_str}    public {base_class_name}{signature} {{ }}\n")
        else:
            f.write(f"{indent_str}    public void {method_name}{signature} {{ }}\n")

    # Nested classes
    for nested_name, nested_node in node.get("nested", {}).items():
        write_class(f, nested_node, nested_name, indent + 1)

    f.write(f"{indent_str}}}\n")


def load_methods_from_yaml(filepath):
    """
    Load methods from a single YAML file and return a list of method entries.
    """
    with open(filepath, "r", encoding="utf-8") as f:
        yaml_data = yaml.safe_load(f)

    methods = []
    for ext in yaml_data.get("extensions", []):
        data_entries = ext.get("data", [])
        for entry in data_entries:
            methods.append(entry)
    return methods

def load_methods_from_directory(dir_path):
    """
    Walk a directory and collect all method entries from .yml/.yaml files.
    
    Returns a flattened list of methods.
    """
    if not os.path.exists(dir_path):
        raise FileNotFoundError(f"Directory does not exist: {dir_path}")
    if not os.path.isdir(dir_path):
        raise NotADirectoryError(f"Not a directory: {dir_path}")

    all_methods = []

    for root, dirs, files in os.walk(dir_path):
        for file in files:
            if file.lower().endswith((".yml", ".yaml")) and not file.lower() == "qlpack.yml" :
                file_path = os.path.join(root, file)
                try:
                    methods = load_methods_from_yaml(file_path)
                    all_methods.extend(methods)
                except Exception as e:
                    print(f"Warning: Failed to load {file_path}: {e}")

    return all_methods


# ---------------------------
# Process Methods
# ---------------------------

def generateStub(methods, output_path):
    """
    Generate stub.cs from a list of methods, handling nested classes and parameter stubs.
    """
    namespace_dict = {}  # namespace -> class tree
    param_types = set()

    # Step 1: Build tree from methods
    for ns, cls, is_pub, method_name, signature, *_ in methods:
        # Properly strip only outer parentheses
        signature_clean = signature.strip()
        if signature_clean.startswith('(') and signature_clean.endswith(')'):
            signature_clean = signature_clean[1:-1].strip()

        param_list = []
        if signature_clean:
            for i, param_type in enumerate(signature_clean.split(',')):
                param_type = param_type.strip()
                # Replace '+' by '.' for nested types in parameters
                param_list.append(f"{param_type.replace('+', '.')} param_{i}")
                # Collect base types for parameter stubs
                for base in extract_base_types(param_type):
                    if base not in TYPE_BLOCKLIST:
                        param_types.add(base)

        signature_with_names = f"({', '.join(param_list)})"

        if ns not in namespace_dict:
            namespace_dict[ns] = {}
        add_class_method(namespace_dict[ns], cls, (is_pub, method_name, signature_with_names))

    # Step 2: Add parameter type stubs to correct nested class location
    for param_type in param_types:
        ns, full_cls = get_namespace_class(param_type)
        class_hierarchy = full_cls.split('+')
        constructor_name = class_hierarchy[-1]

        if ns not in namespace_dict:
            namespace_dict[ns] = {}

        current_level = namespace_dict[ns]
        for i, cls_name in enumerate(class_hierarchy):
            if cls_name not in current_level:
                current_level[cls_name] = {'methods': [], 'nested': {}}
            if i == len(class_hierarchy) - 1:
                # Add constructor method at the deepest level
                current_level[cls_name]['methods'].append((True, constructor_name, "()"))
            current_level = current_level[cls_name]['nested']

    for ns in namespace_dict:
        add_default_constructors(namespace_dict[ns])

    # Step 3: Write stub.cs
    os.makedirs(output_path, exist_ok=True)
    output_file = os.path.join(output_path, "stub.cs")

    with open(output_file, "w", encoding="utf-8") as f:
        f.write("// Auto-generated stub.cs\n\n")
        #import json
        #print(json.dumps(namespace_dict, indent=4))
        for ns, class_tree in namespace_dict.items():
            f.write(f"namespace {ns} {{\n")
            for class_name, class_node in class_tree.items():
                write_class(f, class_node, class_name, indent=1)
                f.write("\n")
            f.write("}\n\n")

    print(f"stub.cs generated successfully at: {output_file}")



def generateTests(methods, output_path, fileName):

    namespace_name = "Test"
    class_name = fileName.strip(".cs")
    func_name_count = defaultdict(int)

    # Mapping types to tainted fields
    tainted_fields = {
        "System.String": "taintedString",
        "System.Byte[]": "taintedBytes",
        "System.IO.Stream": "taintedStream",
        "System.IO.TextReader": "taintedReader",
        "System.Xml.XmlReader": "taintedXmlReader",
        "System.IO.BinaryReader": "taintedBinaryReader"
    }

    os.makedirs(output_path, exist_ok=True)
    if not fileName.lower().endswith(".cs"):
        fileName+=".cs"
    output_file = os.path.join(output_path, fileName)
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(f"// Auto-generated {fileName}.cs\n\n")
        
        # Collect all namespaces
        all_namespaces = set(ns for ns, *_ in methods)
        all_namespaces.update(["System", "System.IO", "System.Text", "System.Xml"])
        for ns in sorted(all_namespaces):
            f.write(f"using {ns};\n")
        f.write("\n")
        
        f.write(f"namespace {namespace_name} {{\n")
        f.write(f"    public class {class_name} {{\n\n")
        
        # Declare class-level tainted fields (no initialization)
        f.write("        // Simulated tainted input\n")
        f.write("        string taintedString;\n")
        f.write("        byte[] taintedBytes;\n")
        f.write("        MemoryStream taintedStream;\n")
        f.write("        TextReader taintedReader;\n")
        f.write("        XmlReader taintedXmlReader;\n")
        f.write("        BinaryReader taintedBinaryReader;\n\n")
        
        # Constructor to initialize fields
        f.write(f"        public {class_name}() {{\n")
        f.write('            taintedString = "tainted_input";\n')
        f.write("            taintedBytes = Encoding.UTF8.GetBytes(taintedString);\n")
        f.write("            taintedStream = new MemoryStream(taintedBytes);\n")
        f.write("            taintedReader = new StringReader(taintedString);\n")
        f.write("            taintedXmlReader = XmlReader.Create(taintedReader);\n")
        f.write("            taintedBinaryReader = new BinaryReader(taintedStream);\n")
        f.write("        }\n\n")
        
        # Generate test methods
        for method_array in methods:
            ns, cls, is_pub, method_name, signature, _, arg_index, *_ = method_array
            signature_clean = signature.replace("+", ".").strip()
            inner = signature_clean[1:-1] if signature_clean.startswith("(") and signature_clean.endswith(")") else signature_clean
            param_list = []
            if inner:
                for i, param_type in enumerate(inner.split(",")):
                    param_type = param_type.strip()
                    # Check if this is the tainted parameter
                    m = re.match(r"Argument\[(\d+)\]", arg_index)
                    is_tainted = m and int(m.group(1)) == i
                    if is_tainted and param_type in tainted_fields:
                        param_value = tainted_fields[param_type]
                    else:
                        param_value = f"default({param_type})"
                    param_list.append((param_type, param_value))
            
            # Unique function name
            base_name = f"Test_{method_name}"
            count = func_name_count[base_name]
            func_name_count[base_name] += 1
            func_name = base_name if count == 0 else f"{base_name}{count}"
            
            f.write(f"        // #- {method_array}\n")
            f.write(f"        public void {func_name}() {{\n")
            
            # Instantiate class or call constructor
            nested = False
            if "+" in cls:
                nested = True
            cls = cls.replace("+", ".")
            param_names = ", ".join([v for _, v in param_list])
            if method_name == cls or (nested and method_name == cls.split(".")[-1]):
                f.write(f"            var tmp = new {ns}.{cls}({param_names});\n")
            else:
                f.write(f"            var obj = new {ns}.{cls}();\n")
                f.write(f"            obj.{method_name}({param_names});\n")
            
            f.write("        }\n\n")
        
        f.write("    }\n")
        f.write("}\n")

    print(f"{fileName}.cs generated successfully.")

def generate(model_dir, output_path, fileName):
    methods = load_methods_from_directory(model_dir)

    # Merge always present methods into main method list
    stubMethods = ALWAYS_METHODS + methods
    
    generateStub(stubMethods, output_path)
    generateTests(methods, output_path, fileName)

# ---------------------------
# Main CLI
# ---------------------------

def main():
    parser = argparse.ArgumentParser(description="Generate C# stub from YAML method definitions.")
    parser.add_argument("-m", "--model-dir", default="../ql/csharp/ext/manual/GadgetSinks/", help="Directory containing YAML method files")
    parser.add_argument("-o", "--output", default="../ql/csharp/tests/tests/ExtensionSinks/", help="Output directory for stub.cs")
    parser.add_argument("-f", "--file-name", default="ExtensionSinks.cs", help="Name of the C# file for the Tests.")

    args = parser.parse_args()

    generate(args.model_dir, args.output, args.file_name)

if __name__ == "__main__":
    main()